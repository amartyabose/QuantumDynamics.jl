<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerically Exact Path Integral Approaches · QuantumDynamics.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumDynamics.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../Bloch-Redfield/">Bloch-Redfield Master Equation</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../../documentation/Bare/">Bare System Propagation</a></li><li><a class="tocitem" href="../../documentation/SpectralDensities/">Spectral Densities</a></li><li><a class="tocitem" href="../../documentation/BlochRedfield/">Bloch-Redfield Master Equation</a></li><li><a class="tocitem" href="../../documentation/Forster/">Incoherent Forster Theory</a></li><li><a class="tocitem" href="../../documentation/EtaCoefficients/">Eta Coefficients</a></li><li><a class="tocitem" href="../../documentation/QuAPI/">Quasi-Adiabatic Propagator Path Integral</a></li><li><a class="tocitem" href="../../documentation/Blip/">Blip Decomposition</a></li><li><a class="tocitem" href="../../documentation/QCPI/">Quantum-Classical Path Integral</a></li><li><a class="tocitem" href="../../documentation/TEMPO/">Time-Evolving Matrix Product Operators</a></li><li><a class="tocitem" href="../../documentation/PCTNPI/">Pairwise-Connected Tensor Network Path Integral</a></li><li><a class="tocitem" href="../../documentation/TTM/">Transfer Tensor Method</a></li><li><a class="tocitem" href="../../documentation/HEOM/">Hierarchical Equations of Motion</a></li><li><a class="tocitem" href="../../documentation/Utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerically Exact Path Integral Approaches</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerically Exact Path Integral Approaches</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/amartyabose/QuantumDynamics.jl/blob/main/docs/src/tutorial/BasicPI.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerically-Exact-Path-Integral-Approaches"><a class="docs-heading-anchor" href="#Numerically-Exact-Path-Integral-Approaches">Numerically Exact Path Integral Approaches</a><a id="Numerically-Exact-Path-Integral-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Numerically-Exact-Path-Integral-Approaches" title="Permalink"></a></h1><p>The family of methods based on Quasi-Adiabatic Propagator Path Integral (QuAPI) is a family of numerically exact non-perturbative techniques for simulating a quantum system interacting with a harmonic environment. It simulates the reduced density matrix of an <code>n</code>-level quantum system using path integrals and the harmonic bath is incorporated through the Feynman-Vernon influence functional. The tracing out of the harmonic bath leads to a non-Markovian memory, which is used as a convergence parameter.</p><p>While at a first glance, the restriction to harmonic environments may seem arbitrarily limiting, it is actually quite general. Under the Gaussian response theory, when the environment is large and has enough &quot;independent&quot; degrees of freedom, the impact of an atomistically-described environment can be mapped onto a bath of harmonic oscillators with given frequencies and coupling strengths. Together these frequencies and couplings are described through the spectral density of the solvent which is given by</p><p class="math-container">\[J(\omega) = \frac{\pi}{2} \sum_j \frac{c_j^2}{\omega_j}\delta\left(\omega-\omega_j\right).\]</p><p>The full system-harmonic environment Hamiltonian is then given by</p><p class="math-container">\[\hat{H} = \hat{H}_0 + \hat{H}_\text{env}\\
\hat{H}_\text{env} = \sum_j \frac{p_j^2}{2} + \frac{1}{2}\omega_j^2\left(x_j - \frac{c_j}{\omega_j^2}\hat{s}\right)^2,\]</p><p>where <span>$\hat{s}$</span> is the system operator that interacts with the environment.</p><p>The most common prototypical model problem of open quantum systems is the spin-boson problem. We will illustrate the approach taken by QuantumDynamics to make the various methods compatible with each other by demonstrating how the same basic setup works for all the basic methods.</p><p>The basic steps involved for these simulations are</p><ol><li>Define the system<ol><li>Define the Hamiltonian</li><li>Define the spectral density corresponding to the solvent</li><li>Specify the temperature</li></ol></li><li>Obtain the short-time propagators that are used to construct the path integral</li><li>Build on top of the short-time propagators using the Feynman-Vernon influence functional.</li></ol><p>In this tutorial, we will show how to use the different methods of the QuAPI family to obtain results for a single parameter. This side-by-side use of all the algorithms serve to emphasize the similarity of the APIs involved.</p><pre><code class="language-julia hljs">using QuantumDynamics

H0 = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)        # 1.1 Define the system Hamiltonian
Jw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density
β = 5.0    # 1.3 Inverse temperature</code></pre><p>Let us plot the spectral density. Assuming that you are using the Plots.jl library, the following code will work:</p><pre><code class="language-julia hljs">ω = 0:0.1:100
plot(ω, Jw.(ω), lw=2, label=&quot;&quot;)
xlabel!(L&quot;\omega&quot;)
ylabel!(L&quot;J(\omega)&quot;)</code></pre><p><img src="../../tutorial_examples/spectral_density.png" alt="Spectral density"/></p><p>Next, we calculate the short-time forward-backward propagators, which require us to define the time-step and number of steps of simulation.</p><pre><code class="language-julia hljs">dt = 0.25
ntimes = 100
fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)</code></pre><h2 id="Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)"><a class="docs-heading-anchor" href="#Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)">Iterative Quasi-Adiabatic propagator Path Integral (QuAPI)</a><a id="Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)" title="Permalink"></a></h2><p>Finally, the methods incorporate the influence functional on top of the propagator. First, we demonstrate the basic QuAPI algorithm (<a href="https://doi.org/10.1063/1.531046">QuAPI review</a>) at different memory lengths, <code>kmax</code>. The exact method can also be used with filtering if the optional argument of <code>extraargs</code> of type <code>QuAPI.QuAPIArgs</code> is provided.</p><pre><code class="language-julia hljs">ρ0 = [1.0+0.0im 0; 0 0]
sigma_z = []
kmax = [2,5,9]
time = Vector{Float64}()
for k in kmax
    @time t, ρs = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)
    global time = t
    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))
end</code></pre><p><img src="../../tutorial_examples/QuAPI.png" alt="QuAPI Convergence"/></p><h2 id="Time-Evolving-Matrix-Product-Operator-(TEMPO)"><a class="docs-heading-anchor" href="#Time-Evolving-Matrix-Product-Operator-(TEMPO)">Time-Evolving Matrix Product Operator (TEMPO)</a><a id="Time-Evolving-Matrix-Product-Operator-(TEMPO)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Evolving-Matrix-Product-Operator-(TEMPO)" title="Permalink"></a></h2><p>Recently ideas of tensor network have been used to make path integral calculations more efficient. The correlation between the time-points decrease with the temporal separation between them. This allows for significantly compressed matrix product state (MPS) representation of the so-called path-amplitude tensor. The influence functional is represented as a matrix product operator and applied to this path-amplitude MPS to incorporate the effect of the baths. The interface is kept consistent with the other path integral methods like QuAPI. The MPO-MPS applications is controlled through a <code>cutoff</code> threshold and a <code>maxdim</code> threshold. The method used for applying an MPO to an MPS can be chosen to be one of <code>naive</code>, <code>densitymatrix</code>, or <code>fit</code>. These settings are passed as <code>extraargs</code>, which is an object of <code>TNPI.TNPIArgs</code>. By default, <code>cutoff=1e-8</code>, <code>maxdim=50</code> and <code>method=naive</code>. These ideas have been outlined in <a href="https://dx.doi.org/10.1038/s41467-018-05617-3">TEMPO</a>. The implementation follows the details of <a href="https://arxiv.org/abs/2106.12523">TNPI</a> incorporating multiple baths and the QuAPI splitting.</p><pre><code class="language-julia hljs">ρ0 = [1.0+0.0im 0; 0 0]
sigma_z_TEMPO = []
kmax = [2,5,9]
time = Vector{Float64}()
for k in kmax
    @time t, ρs = TEMPO.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)
    global time = t
    push!(sigma_z_TEMPO, real.(ρs[:,1,1] .- ρs[:,2,2]))
end</code></pre><p><img src="../../tutorial_examples/TEMPO.png" alt="TEMPO Convergence"/></p><h2 id="Transfer-Tensor-Method"><a class="docs-heading-anchor" href="#Transfer-Tensor-Method">Transfer Tensor Method</a><a id="Transfer-Tensor-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-Tensor-Method" title="Permalink"></a></h2><p>Since the iteration regime can be quite costly, we have implemented the non-Markovian transfer tensor method (TTM) (<a href="https://link.aps.org/doi/10.1103/PhysRevLett.112.110401">TTM</a>). This is invoked in the following manner:</p><pre><code class="language-julia hljs">ρ0 = [1.0+0.0im 0; 0 0]
sigma_z = []
rmax = [2,5,9]
time = Vector{Float64}()
for r in rmax
    @time t, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=r, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.build_augmented_propagator)
    global time = t
    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))
end</code></pre><p>The <code>TTM.propagate</code> method, in addition to the usual arguments, takes a function to build the initial propagators for the full-path regime of the simulation. In this case, we are using QuAPI to build the propagators in the full-path segment, as indicated by <code>path_integral_routine=QuAPI.build_augmented_propagator</code>. Other possible choices are <code>path_integral_routine=Blip.build_augmented_propagator</code>, <code>path_integral_routine=TEMPO.build_augmented_propagator</code> and <code>path_integral_routine=PCTNPI.build_augmented_propagator</code>. Also notice that because each of these <code>path_integral_routine</code>s take different <code>extraargs</code>, it is not possible to provide a default. Here, it is necessary for the <code>extraargs</code> to be provided and it needs to be consistent with the <code>path_integral_routine</code>.</p><p><img src="../../tutorial_examples/QuAPI-TTM.png" alt="TTM QuAPI"/></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 11:23">Monday 11 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
