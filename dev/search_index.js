var documenterSearchIndex = {"docs":
[{"location":"documentation/PCTNPI/#Pairwise-Connected-Tensor-Network-Path-Integral","page":"Pairwise-Connected Tensor Network Path Integral","title":"Pairwise-Connected Tensor Network Path Integral","text":"","category":"section"},{"location":"documentation/PCTNPI/","page":"Pairwise-Connected Tensor Network Path Integral","title":"Pairwise-Connected Tensor Network Path Integral","text":"It has been shown in PC-TNPI that a general tensor network can be formulated that manifestly captures the symmetries present in the path integral expression. It can be used by itself or as a starting point for deriving other tensor network decompositions of path integrals.","category":"page"},{"location":"documentation/PCTNPI/#API","page":"Pairwise-Connected Tensor Network Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/PCTNPI/","page":"Pairwise-Connected Tensor Network Path Integral","title":"Pairwise-Connected Tensor Network Path Integral","text":"PCTNPI.build_augmented_propagator","category":"page"},{"location":"documentation/PCTNPI/#QuantumDynamics.PCTNPI.build_augmented_propagator","page":"Pairwise-Connected Tensor Network Path Integral","title":"QuantumDynamics.PCTNPI.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps using the PCTNPI approach. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"tutorial/EmpiricalApproaches/#Empirical-Approaches","page":"Empirical Approaches","title":"Empirical Approaches","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Before jumping into systematic solutions of the dynamics of open quantum systems, let us illustrate a couple of ad-hoc approaches to modeling such systems. The first approach considered here is the celebrated Linblad Master Equations. Thereafter, we also demonstrate how to use QuantumDynamics to simulate the dynamics corresponding to non-Hermitian systems.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"For all the examples that are shown here, the following setup remains the same:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\ndt = 0.125\nntimes = 200\n\nρ0 = [1.0+0.0im 0.0; 0.0 0.0]","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"We are using a time-step of 0125 and simulating for 200 time steps. We start the simulation from an initial condition localized on one of the states.","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Bare-Hermitian-System","page":"Empirical Approaches","title":"Bare Hermitian System","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The Hermitian Hamiltonian considered here is:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"H = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Now we solve Heisenberg's equation of motion for the reduced density matrix:","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes);","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"(Image: Bare Hermitian System)","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Lindblad-Master-Equation","page":"Empirical Approaches","title":"Lindblad Master Equation","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The same interface can be used to solve the Lindblad Master Equation by providing an array of non-Hermitian dissipative collapse operators, L.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"L = [[0.0+0.0im 0; 0.75 0]]\ntimes, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes, L);","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"(Image: Lindblad Master Equation)","category":"page"},{"location":"tutorial/EmpiricalApproaches/#Non-Hermitian-System","page":"Empirical Approaches","title":"Non-Hermitian System","text":"","category":"section"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"Dynamics described by non-Hermitian systems is heavily dependent on the type of non-Hermitian term. Consider an arbitrary non-PT-symmetric non-Hermitian Hamiltonian.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"H = [exp(-1.5im) -0.75; -0.75 exp(0.75im)]\ndatum = (H[1,1]+H[2,2])/2\nH[1,1] -= datum\nH[2,2] -= datum","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"The dynamics is simulated in a way that is identical to that of the bare Hermitian system.","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"times, ρs = Bare.propagate(; Hamiltonian=H, ρ0, dt, ntimes);\nplot(times, real(ρs[:,1,1]), label=L\"P_1(t)\", lw = 2)\nplot!(times, real(ρs[:,2,2]), label=L\"P_2(t)\", lw = 2)\nxlabel!(L\"t\")\nylabel!(\"Population\")","category":"page"},{"location":"tutorial/EmpiricalApproaches/","page":"Empirical Approaches","title":"Empirical Approaches","text":"(Image: Non-Hermitian System)","category":"page"},{"location":"tutorial/QCPI/#Quantum-Classical-Path-Integral-(QCPI)","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral (QCPI)","text":"","category":"section"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI is a numerically exact method for simulating a quantum system interacting with a large thermal environment. This environment is described through force-fields or ab initio molecular dynamics trajectories. While the Gaussian response results are often very good, it is an exciting prospect to be able to solve the full atomistic problem. Here, we implement the harmonic-backreaction (HBR) version of QCPI, which charts a middle-ground between the solution to the fully atomistic problem and the fully harmonic problem. In HBR, the full anharmonicity of the solvent is taken into account in the classical temperature-dependent part of the memory. The quantum, temperature-independent part of the memory is dealt with harmonically.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"In QuantumDynamics.jl, QCPI is a wrapper around other base path integral methods like QuAPI, TNPI, or Blips. So, we automatically get standard HBR-QCPI (a combination QCPI with QuAPI), blip HBR-QCPI (a combination of QCPI with blips) and HBR-TNPI (a combination of QCPI with TNPI) based on the \"backend\" used.","category":"page"},{"location":"tutorial/QCPI/#Example","page":"Quantum-Classical Path Integral","title":"Example","text":"","category":"section"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The basic simulation starts in a manner that should familiar from the setup of a QuAPI or TNPI simulation.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = Utilities.create_tls_hamiltonian(; ϵ=2.0, Δ=2.0)        # 1.1 Define the system Hamiltonian\nρ0 = [1.0+0.0im 0.0; 0.0 0.0]\nβ = 5.0\ndt = 0.25\nntimes = 100","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Right now QCPI only supports harmonic solvents, but it is possible to code up generic atomistic solvents or simply provide adapters for packages like Molly.jl or DFTK.jl. So, let's define the harmonic bath and discretize it into 100 oscillators for the classical trajectories.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Jw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nω, c = SpectralDensities.discretize(Jw, 100)\nhb = Solvents.HarmonicBath(β, ω, c, [1.0, -1.0], 100);","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"SpectralDensities.discretize discretizes a given spectral density into oscillators. Then we create a Solvents.HarmonicBath bath at the given inverse temperature, with the frequencies and couplings. The last two arguments to Solvents.HarmonicBath are the system operator along which the solvent acts and the number of initial conditions that would be sampled. How the solvent samples the phase-space is dependent on the particular implementation. For a harmonic bath, one can simply sample the multidimensional Gaussian distributions. For molecular solvents, one can implement molecular dynamics trajectories with a thermostat.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"One can generate the ensemble averaged classical path result, which contains only the real part of memory. This involves generating the correct propagators and using them to propagate an initial reduced density matrix.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"EACP_fbU = Propagators.calculate_average_reference_propagators(; Hamiltonian=H0, solvent=hb, classical_dt=dt/100, dt, ntimes);\ntimes_EACP, ρs_EACP = Utilities.apply_propagator(; propagators=EACP_fbU, ρ0, ntimes, dt);","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"For a full QCPI calculation, we use the propagate interface:","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"times_QCPI, ρs_QCPI = QCPI.propagate(; Hamiltonian=H0, Jw, solvent=hb, ρ0, classical_dt=dt/100, dt, ntimes, kmax=3, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.propagate)","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Lastly, we run a TTM-QuAPI simulation for comparison and plot the results.","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt, ntimes);\n@time times, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β, ρ0, dt, ntimes, rmax=5, extraargs=Blip.BlipArgs(), path_integral_routine=Blip.build_augmented_propagator_QuAPI_TTM)","category":"page"},{"location":"tutorial/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"(Image: QCPI)","category":"page"},{"location":"documentation/TEMPO/#Time-Evolving-Matrix-Product-Operators","page":"Time-Evolving Matrix Product Operators","title":"Time-Evolving Matrix Product Operators","text":"","category":"section"},{"location":"documentation/TEMPO/","page":"Time-Evolving Matrix Product Operators","title":"Time-Evolving Matrix Product Operators","text":"Time-Evolving Matrix Product Operators (TEMPO) uses matrix product states and operators to reduces the computational complexity and storage requirement for doing a path integral simulation. This allows for simulation of significantly larger systems with longer lengths of non-Markovian memory. The fundamental ideas are outlined in TEMPO. The implementation closely follows the details presented in TNPI.","category":"page"},{"location":"documentation/TEMPO/#API","page":"Time-Evolving Matrix Product Operators","title":"API","text":"","category":"section"},{"location":"documentation/TEMPO/","page":"Time-Evolving Matrix Product Operators","title":"Time-Evolving Matrix Product Operators","text":"TEMPO.propagate","category":"page"},{"location":"documentation/TEMPO/#QuantumDynamics.TEMPO.propagate","page":"Time-Evolving Matrix Product Operators","title":"QuantumDynamics.TEMPO.propagate","text":"propagate(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, ρ0, dt::Real, ntimes::Int, kmax::Int, extraargs::QuAPIArgs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nGiven a time-series of system forward-backward propagators, fbU, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses TEMPO to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. A non-Markovian memory of kmax steps is used in this simulation. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\nRelevant citations:\n\nStrathearn, A.; Kirton, P.; Kilda, D.; Keeling, J.; Lovett, B. W. Efficient Non-Markovian Quantum Dynamics Using Time-Evolving Matrix Product Operators. Nature Communications 2018, 9, 3322. https://doi.org/10.1038/s41467-018-05617-3.\nBose, A.; Walters, P. L. A Tensor Network Representation of Path Integrals: Implementation and Analysis. arXiv pre-print server arXiv:2106.12523 2021.\n\nArguments:\n\nρ0: initial reduced density matrix\nfbU: time-series of forward-backward propagators\nJw: array of spectral densities\nsvec: diagonal elements of system operators through which the corresponding baths interact. QuAPI currently only works for baths with diagonal coupling to the system.\ndt: time-step for recording the density matrices\nntimes: number of time steps of simulation\nkmax: number of steps within memory\nextraargs: extra arguments for the TEMPO algorithm. Contains the cutoff threshold for SVD filtration, the maximum bond dimension, maxdim, and the algorithm of applying an MPO to an MPS.\n\n\n\n\n\n","category":"function"},{"location":"documentation/TEMPO/","page":"Time-Evolving Matrix Product Operators","title":"Time-Evolving Matrix Product Operators","text":"TEMPO.build_augmented_propagator","category":"page"},{"location":"documentation/TEMPO/#QuantumDynamics.TEMPO.build_augmented_propagator","page":"Time-Evolving Matrix Product Operators","title":"QuantumDynamics.TEMPO.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int, Nothing}=nothing, extraargs::TEMPOArgs=TEMPOArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps using the TEMPO scheme. If kmax is specified, the full memory simulation is only done for kmax steps, else it is done for all ntimes steps. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\nRelevant citations:\n\nStrathearn, A.; Kirton, P.; Kilda, D.; Keeling, J.; Lovett, B. W. Efficient Non-Markovian Quantum Dynamics Using Time-Evolving Matrix Product Operators. Nature Communications 2018, 9, 3322. https://doi.org/10.1038/s41467-018-05617-3.\nBose, A.; Walters, P. L. A Tensor Network Representation of Path Integrals: Implementation and Analysis. arXiv pre-print server arXiv:2106.12523 2021.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Compile/#Compiling-QuantumDynamics.jl","page":"Compiling QuantumDynamics.jl","title":"Compiling QuantumDynamics.jl","text":"","category":"section"},{"location":"documentation/Compile/","page":"Compiling QuantumDynamics.jl","title":"Compiling QuantumDynamics.jl","text":"QuantumDynamics.compile()","category":"page"},{"location":"documentation/Compile/#QuantumDynamics.compile-Tuple{}","page":"Compiling QuantumDynamics.jl","title":"QuantumDynamics.compile","text":"QuantumDynamics.compile(; dir = \"/home/runner/.julia/sysimages\",\n                   filename = \"sys_qd.so\")\n\nCompile QuantumDynamics.jl with PackageCompiler. This will take some time, perhaps a few minutes.\n\nThis will create a system image containing the compiled version of QuantumDynamics located at dir/filename, by default /home/runner/.julia/sysimages/sys_qd.so.\n\nYou will be able to start Julia with a compiled version of QuantumDynamics using:\n\n~ julia --sysimage /home/runner/.julia/sysimages/sys_qd.so\n\nand you should see that the startup times and JIT compilation times are substantially improved when you are using QuantumDynamics.\n\nIn unix, you can create an alias with the Bash command:\n\n~ alias julia_qd=\"julia --sysimage /home/runner/.julia/sysimages/sys_qd.so -e 'using QuantumDynamics' -i\"\n\nwhich you can put in your ~/.bashrc, ~/.zshrc, etc. This also executes using QuantumDynamics so that QuantumDynamics is loaded and ready to use, you can leave off -e 'using QuantumDynamics' -i if you don't want that. Then you can start Julia with a version of QuantumDynamics installed with the command:\n\n~ julia_qd\n\nNote that if you update QuantumDynamics to a new version, for example with using Pkg; Pkg.update(\"QuantumDynamics\"), you will need to run the QuantumDynamics.compile() command again to recompile the new version of QuantumDynamics.\n\n\n\n\n\n","category":"method"},{"location":"documentation/BlochRedfield/#Bloch-Redfield-Master-Equation","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"","category":"section"},{"location":"documentation/BlochRedfield/#API","page":"Bloch-Redfield Master Equation","title":"API","text":"","category":"section"},{"location":"documentation/BlochRedfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"BlochRedfield.propagate","category":"page"},{"location":"documentation/BlochRedfield/#QuantumDynamics.BlochRedfield.propagate","page":"Bloch-Redfield Master Equation","title":"QuantumDynamics.BlochRedfield.propagate","text":"propagate(; Hamiltonian::AbstractMatrix{ComplexF64}, Jw::AbstractVector{T}, β::Real, ρ0::AbstractMatrix{ComplexF64}, dt::Real, ntimes::Int, sys_ops::Vector{Matrix{ComplexF64}}, extraargs::Utilities.DiffEqArgs=Utilities.DiffEqArgs()) where {T<:SpectralDensities.AnalyticalSpectralDensity}\n\nGiven a system Hamiltonian, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses Bloch-Redfield Master Equations to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. The ith bath, described by Jw[i], interacts with the system through the operator with the values of svec[j]. The default solver used here is Tsit5 with a relative and absolute error cutoffs of 1e-10.\n\n\n\n\n\n","category":"function"},{"location":"documentation/BlochRedfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"BlochRedfield.get_Rtensor","category":"page"},{"location":"documentation/BlochRedfield/#QuantumDynamics.BlochRedfield.get_Rtensor","page":"Bloch-Redfield Master Equation","title":"QuantumDynamics.BlochRedfield.get_Rtensor","text":"get_Rtensor(eigvals, eigvecs, Jw::AbstractVector{T}, svec::AbstractVector{Matrix{ComplexF64}}, β::Real) where {T<:SpectralDensities.AnalyticalSpectralDensity}\n\nCalculates the Bloch-Redfield R tensor given the eigenvalues, eigvals, and eigenvectors, eigvecs, of the system Hamiltonian, an inverse temperature β, and a number of baths specified by their spectral densities, Jw, and the operator through which they interact, svec.\n\n\n\n\n\n","category":"function"},{"location":"documentation/TTM/#Transfer-Tensor-Method-(TTM)","page":"Transfer Tensor Method","title":"Transfer Tensor Method (TTM)","text":"","category":"section"},{"location":"documentation/TTM/","page":"Transfer Tensor Method","title":"Transfer Tensor Method","text":"This module provides the interface for generating propagators beyond an entanglement length using TTM.","category":"page"},{"location":"documentation/TTM/#API","page":"Transfer Tensor Method","title":"API","text":"","category":"section"},{"location":"documentation/TTM/","page":"Transfer Tensor Method","title":"Transfer Tensor Method","text":"TTM.propagate","category":"page"},{"location":"documentation/TTM/#QuantumDynamics.TTM.propagate","page":"Transfer Tensor Method","title":"QuantumDynamics.TTM.propagate","text":"propagate(; fbU::Array{ComplexF64, 3}, Jw::Vector{T}, β::Real, ρ0::Matrix{ComplexF64}, dt::Real, ntimes::Int, rmax::Int, path_integral_routine, extraargs::Utilities.ExtraArgs, svec=[1.0 -1.0], QuAPI::Bool=false, verbose::Bool=false, reference_prop=false) where {T<:SpectralDensities.SpectralDensity}\n\nUses TTM to propagate the dynamics starting from ρ0. TTM uses propagators for different time-spans and these are calculated using the path_integral_routine, which returns these propagators after solving the Feynman-Vernon influence functional. If QuAPI is set to false, the default TTM method is used. Setting QuAPI to true lifts the time-translational invariance requirements of the method. Currently it is possible to use QuAPI, Blip, TEMPO, and PCTNPI to generate the propagators when QuAPI=false. The functions are called build_augmented_propagators. The additional propagators required when QuAPI=true can be simulated using the build_augmented_propagators_QuAPI_TTM of QuAPI and Blip modules.\n\nUnlike the base methods, TTM.propagate cannot assume the default type of extraargs required for the path_integral_routine. Therefore, unlike QuAPI.propagate or QuAPI.build_augmented_propagator, TTM.propagate needs to be supplied an extraargs parameter compatible with the path_integral_routine passed in. Passing in incompatible extraargs, eg. Blip.BlipArgs with QuAPI.build_augmented_propagator, would result in errors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/TTM/","page":"Transfer Tensor Method","title":"Transfer Tensor Method","text":"TTM.get_propagators","category":"page"},{"location":"documentation/TTM/#QuantumDynamics.TTM.get_propagators","page":"Transfer Tensor Method","title":"QuantumDynamics.TTM.get_propagators","text":"get_propagators(; fbU::Array{<:Complex,3}, Jw::Vector{T}, β, dt, ntimes, rmax, kmax::Union{Int, Nothing}=nothing, path_integral_routine, extraargs::Utilities.ExtraArgs, svec=[1.0 -1.0], verbose::Bool=false, reference_prop=false, output::Union{Nothing,HDF5.Group}=nothing) where {T<:SpectralDensities.SpectralDensity}\n\nCalculates a timeseries of forward-backward propagators for an open quantum system using base TTM. It calls the path_integral_routine with the bare system's forward-backward propagator and the spectral density to obtain the propagators till rmax time-points. Then it uses TTM to generate the other propagators.\n\n\n\n\n\n","category":"function"},{"location":"documentation/TTM/","page":"Transfer Tensor Method","title":"Transfer Tensor Method","text":"TTM.get_propagators_QuAPI","category":"page"},{"location":"documentation/TTM/#QuantumDynamics.TTM.get_propagators_QuAPI","page":"Transfer Tensor Method","title":"QuantumDynamics.TTM.get_propagators_QuAPI","text":"get_propagators_QuAPI(; fbU::Array{ComplexF64,3}, Jw::Vector{T}, β, dt, ntimes, rmax, path_integral_routine, extraargs::Utilities.ExtraArgs, svec=[1.0 -1.0], verbose::Bool=false, reference_prop=false) where {T<:SpectralDensities.SpectralDensity}\n\nCalculates a timeseries of forward-backward propagators for an open quantum system using a generalized TTM fit for QuAPI. It calls the path_integral_routine with the bare system's forward-backward propagator and the spectral density to obtain the propagators till rmax time-points. Then it uses TTM to generate the other propagators.\n\n\n\n\n\n","category":"function"},{"location":"documentation/HEOM/#Hierarchy-Equations-of-Motion","page":"Hierarchical Equations of Motion","title":"Hierarchy Equations of Motion","text":"","category":"section"},{"location":"documentation/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"This module provides the necessary tools for doing HEOM simulations. While the equations of motion have been reported in many articles, the current implementation is based on a relatively recent paper, HEOM1. It should be noted that this is a particularly naive implementation of the algorithm that only works for the simplest of case of a Drude-Lorentz spectral density. Scaling of the auxiliary density operators is employed. The integration of the equations of motion is done using the DifferentialEquations.jl package.","category":"page"},{"location":"documentation/HEOM/#API","page":"Hierarchical Equations of Motion","title":"API","text":"","category":"section"},{"location":"documentation/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"HEOM.get_vecs","category":"page"},{"location":"documentation/HEOM/#QuantumDynamics.HEOM.get_vecs","page":"Hierarchical Equations of Motion","title":"QuantumDynamics.HEOM.get_vecs","text":"get_vecs(len::Int, L::Int)\n\nGet a vector of vectors of length len, where the sum is L.\n\n\n\n\n\n","category":"function"},{"location":"documentation/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"HEOM.setup_simulation","category":"page"},{"location":"documentation/HEOM/#QuantumDynamics.HEOM.setup_simulation","page":"Hierarchical Equations of Motion","title":"QuantumDynamics.HEOM.setup_simulation","text":"setup_simulation(num_baths::Int, num_modes::Int, Lmax::Int)\n\nSets up the simulation parameters for a problem with num_baths baths, num_modes extra matsubara modes, and a hierarchy Lmax levels deep.\n\nReturns a tuple of: nveclist: List of the possible subscripts, n, in HEOM. Each element in the list is a represented as a matrix. Every row corresponds to a bath. npluslocs[b,m,l]: Given the lth nvector, returns the location of the nvector if the bth bath's mth Matsubara mode is increased by one. nminuslocs[b,m,l]: Given the lth nvector, returns the location of the nvector if the bth bath's mth Matsubara mode is decreased by one.\n\n\n\n\n\n","category":"function"},{"location":"documentation/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"HEOM.propagate","category":"page"},{"location":"documentation/HEOM/#QuantumDynamics.HEOM.propagate","page":"Hierarchical Equations of Motion","title":"QuantumDynamics.HEOM.propagate","text":"propagate(; Hamiltonian::AbstractMatrix{ComplexF64}, ρ0::AbstractMatrix{ComplexF64}, β::Real, Jw::AbstractVector{SpectralDensities.DrudeLorentz}, sys_ops::Vector{Matrix{ComplexF64}}, num_modes::Int, Lmax::Int, dt::Real, ntimes::Int, threshold::Float64=0.0, external_fields::Union{Nothing,Vector{Utilities.ExternalField}}=nothing, extraargs::Utilities.DiffEqArgs=Utilities.DiffEqArgs())\n\nUses HEOM to propagate the initial reduced density matrix, ρ0, under the given Hamiltonian, and set of spectral densities, Jw, interacting with the system through sys_ops.\n\nρ0: initial reduced density matrix Hamiltonian: system Hamiltonian external_fields: either nothing or a vector of external time-dependent fields Jw: array of spectral densities sys_ops: system operators through which the corresponding baths interact\n\nnum_modes: number of Matsubara modes to be considered Lmax: cutoff for maximum number of levels dt: time-step for recording the density matrices ntimes: number of time steps of simulation threshold: filtration threshold extraargs: extra arguments for the differential equation solver\n\n\n\n\n\n","category":"function"},{"location":"documentation/SpectralDensities/#Spectral-Densities","page":"Spectral Densities","title":"Spectral Densities","text":"","category":"section"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"The interaction of a quantum system with a condensed phase environment is often captured through the spectral density. QuantumDynamics has a built-in support for a few of the most common spectral densities and allows for easy incorporation of other spectral densities.","category":"page"},{"location":"documentation/SpectralDensities/#API","page":"Spectral Densities","title":"API","text":"","category":"section"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities","text":"Collection of spectral densities commonly used to describe solvents.\n\n\n\n\n\n","category":"module"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.ExponentialCutoff","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.ExponentialCutoff","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.ExponentialCutoff","text":"ExponentialCutoff(; ξ, ωc, n=1.0, Δs=2.0)\n\nConstruct a model spectral density with an exponential cutoff.\n\nJ(ω) = frac2πΔs^2 ξ fracω^nω_c^n-1 expleft(-fracωωcright)\n\nwhere Δs is the distance between the two system states. The model is Ohmic if n = 1, sub-Ohmic if n < 1, and super-Ohmic if n > 1.\n\n\n\n\n\n","category":"type"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.DrudeLorentz","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.DrudeLorentz","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.DrudeLorentz","text":"DrudeLorentz(; λ, γ, Δs=2.0)\n\nConstruct a model spectral density with a Drude-Lorentz cutoff.\n\nJ(ω) = frac2λΔs^2 fracω γω^2 + γ^2\n\nwhere Δs is the distance between the two system states.\n\n\n\n\n\n","category":"type"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.matsubara_decomposition","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.matsubara_decomposition","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.matsubara_decomposition","text":"matsubara_decomposition(sd::DrudeLorentz, num_modes::Int, β::AbstractFloat)\n\nReturns the Matsubara frequencies, γ, and the expansion coefficients, c.\n\n\n\n\n\n","category":"function"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.SpectralDensityTable","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.SpectralDensityTable","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.SpectralDensityTable","text":"SpectralDensityTable <: ContinuousSpectralDensity\n\nSpectral density provided in tabular form. Contains a vector of ωs and a vector corresponding to jws.\n\n\n\n\n\n","category":"type"},{"location":"documentation/SpectralDensities/","page":"Spectral Densities","title":"Spectral Densities","text":"SpectralDensities.tabulate","category":"page"},{"location":"documentation/SpectralDensities/#QuantumDynamics.SpectralDensities.tabulate","page":"Spectral Densities","title":"QuantumDynamics.SpectralDensities.tabulate","text":"tabulate(sd::SpectralDensityTable, full_real::Bool=true, npoints::Int=100001)\n\nReturns sd.ω and sd.jw.\n\n\n\n\n\ntabulate(sd::T, full_real::Bool=true, npoints::Int=10000) where {T<:AnalyticalSpectralDensity}\n\nReturns a table with ω and J(ω) for ω between -ωmax to ωmax if full_real is true. Otherwise the table ranges for ω between 0 and ωmax with npoints.\n\n\n\n\n\ntabulate(sd::SpectralDensityTable, full_real::Bool=true, npoints::Int=100001)\n\nReturns sd.ω and sd.jw.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/ExternalFieldDynamics/#Dynamics-in-presence-of-an-external-light","page":"Dynamics under External Fields","title":"Dynamics in presence of an external light","text":"","category":"section"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"It has been shown that dissipative tunneling dynamics can be controlled by continuous wave light. We replicate some of the results here. ","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"As usual, first, we set up the system:","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)        # 1.1 Define the system Hamiltonian\nV(t) = 11.96575 * cos(10.0 * t)   # This is the monochromatic light\nEF = Utilities.ExternalField(V, [1.0+0.0im 0.0; 0.0 -1.0])\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.16, ωc=7.5)    # 1.2 Define the spectral density\nβ = 0.5    # 1.3 Inverse temperature","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Calculate the forward-backward propagators. For the case with the external field, we use the Propagators.calculate_bare_propagators_external_field function.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"dt = 0.125\nntimes = 100\nfbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes, external_fields=[EF])\nnofield_fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Simulate the system with the field. TTM does not yet work with time-dependent Hamiltonians. So, we resort to plain QuAPI.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"ρ0 = [1.0+0.0im 0; 0 0]\ntlight, ρlight = TEMPO.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=9)","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Use TTM to simulate the case without the external field.","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"t, ρ = TTM.propagate(; fbU=nofield_fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=9, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.build_augmented_propagator)","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Obtain the Markovian dynamics in presence of light but in absence of the dissipative medium. ","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"t_nodissip, ρ_nodissip = Utilities.apply_propagator(; propagators=fbU, ρ0=ρ0, ntimes=ntimes, dt=dt)","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Finally, we plot all the dynamics both in presence and in absence of light and the dissipative medium. (Image: Light Plot)","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"The localization phenomenon, though not as pronounced as in absence of dissipative media, is still clearly visible. As a comparison, we also simulate the dynamics in presence of a light pulse","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"V1(t) = 11.96575 * cos(10.0 * t) * exp(-t^2 / 8)   # This is the light pulse\nEF1 = Utilities.ExternalField(V1, [1.0+0.0im 0.0; 0.0 -1.0])\nfbU_pulse = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes, external_fields=[EF1])\n@time t, ρs = QuAPI.propagate(; fbU=fbU_pulse, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=9)\nsigma_z_pulse = real.(ρs[:,1,1] .- ρs[:,2,2])","category":"page"},{"location":"tutorial/ExternalFieldDynamics/","page":"Dynamics under External Fields","title":"Dynamics under External Fields","text":"Now, we show the results. (Image: Light pulse)","category":"page"},{"location":"tutorial/BasicPI/#Numerically-Exact-Path-Integral-Approaches","page":"Path Integrals","title":"Numerically Exact Path Integral Approaches","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The family of methods based on Quasi-Adiabatic Propagator Path Integral (QuAPI) is a family of numerically exact non-perturbative techniques for simulating a quantum system interacting with a harmonic environment. It simulates the reduced density matrix of an n-level quantum system using path integrals and the harmonic bath is incorporated through the Feynman-Vernon influence functional. The tracing out of the harmonic bath leads to a non-Markovian memory, which is used as a convergence parameter.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"While at a first glance, the restriction to harmonic environments may seem arbitrarily limiting, it is actually quite general. Under the Gaussian response theory, when the environment is large and has enough \"independent\" degrees of freedom, the impact of an atomistically-described environment can be mapped onto a bath of harmonic oscillators with given frequencies and coupling strengths. Together these frequencies and couplings are described through the spectral density of the solvent which is given by","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"J(omega) = fracpi2 sum_j fracc_j^2omega_jdeltaleft(omega-omega_jright)","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The full system-harmonic environment Hamiltonian is then given by","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"hatH = hatH_0 + hatH_textenv\nhatH_textenv = sum_j fracp_j^22 + frac12omega_j^2left(x_j - fracc_jomega_j^2hatsright)^2","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"where hats is the system operator that interacts with the environment.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The most common prototypical model problem of open quantum systems is the spin-boson problem. We will illustrate the approach taken by QuantumDynamics to make the various methods compatible with each other by demonstrating how the same basic setup works for all the basic methods.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The basic steps involved for these simulations are","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Define the system\nDefine the Hamiltonian\nDefine the spectral density corresponding to the solvent\nSpecify the temperature\nObtain the short-time propagators that are used to construct the path integral\nBuild on top of the short-time propagators using the Feynman-Vernon influence functional.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"In this tutorial, we will show how to use the different methods of the QuAPI family to obtain results for a single parameter. This side-by-side use of all the algorithms serve to emphasize the similarity of the APIs involved.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"using QuantumDynamics\n\nH0 = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)        # 1.1 Define the system Hamiltonian\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nβ = 5.0    # 1.3 Inverse temperature","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Let us plot the spectral density. Assuming that you are using the Plots.jl library, the following code will work:","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ω = 0:0.1:100\nplot(ω, Jw.(ω), lw=2, label=\"\")\nxlabel!(L\"\\omega\")\nylabel!(L\"J(\\omega)\")","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"(Image: Spectral density)","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Next, we calculate the short-time forward-backward propagators, which require us to define the time-step and number of steps of simulation.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"dt = 0.25\nntimes = 100\nfbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)","category":"page"},{"location":"tutorial/BasicPI/#Iterative-Quasi-Adiabatic-propagator-Path-Integral-(QuAPI)","page":"Path Integrals","title":"Iterative Quasi-Adiabatic propagator Path Integral (QuAPI)","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Finally, the methods incorporate the influence functional on top of the propagator. First, we demonstrate the basic QuAPI algorithm (QuAPI review) at different memory lengths, kmax. The exact method can also be used with filtering if the optional argument of extraargs of type QuAPI.QuAPIArgs is provided.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nkmax = [2,5,9]\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"(Image: QuAPI Convergence)","category":"page"},{"location":"tutorial/BasicPI/#Time-Evolving-Matrix-Product-Operator-(TEMPO)","page":"Path Integrals","title":"Time-Evolving Matrix Product Operator (TEMPO)","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Recently ideas of tensor network have been used to make path integral calculations more efficient. The correlation between the time-points decrease with the temporal separation between them. This allows for significantly compressed matrix product state (MPS) representation of the so-called path-amplitude tensor. The influence functional is represented as a matrix product operator and applied to this path-amplitude MPS to incorporate the effect of the baths. The interface is kept consistent with the other path integral methods like QuAPI. The MPO-MPS applications is controlled through a cutoff threshold and a maxdim threshold. The method used for applying an MPO to an MPS can be chosen to be one of naive, densitymatrix, or fit. These settings are passed as extraargs, which is an object of TNPI.TNPIArgs. By default, cutoff=1e-8, maxdim=50 and method=naive. These ideas have been outlined in TEMPO. The implementation follows the details of TNPI incorporating multiple baths and the QuAPI splitting.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z_TEMPO = []\nkmax = [2,5,9]\ntime = Vector{Float64}()\nfor k in kmax\n    @time t, ρs = TEMPO.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=k)\n    global time = t\n    push!(sigma_z_TEMPO, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"(Image: TEMPO Convergence)","category":"page"},{"location":"tutorial/BasicPI/#Transfer-Tensor-Method","page":"Path Integrals","title":"Transfer Tensor Method","text":"","category":"section"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"Since the iteration regime can be quite costly, we have implemented the non-Markovian transfer tensor method (TTM) (TTM). This is invoked in the following manner:","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"ρ0 = [1.0+0.0im 0; 0 0]\nsigma_z = []\nrmax = [2,5,9]\ntime = Vector{Float64}()\nfor r in rmax\n    @time t, ρs = TTM.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, rmax=r, extraargs=QuAPI.QuAPIArgs(), path_integral_routine=QuAPI.build_augmented_propagator)\n    global time = t\n    push!(sigma_z, real.(ρs[:,1,1] .- ρs[:,2,2]))\nend","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"The TTM.propagate method, in addition to the usual arguments, takes a function to build the initial propagators for the full-path regime of the simulation. In this case, we are using QuAPI to build the propagators in the full-path segment, as indicated by path_integral_routine=QuAPI.build_augmented_propagator. Other possible choices are path_integral_routine=Blip.build_augmented_propagator, path_integral_routine=TEMPO.build_augmented_propagator and path_integral_routine=PCTNPI.build_augmented_propagator. Also notice that because each of these path_integral_routines take different extraargs, it is not possible to provide a default. Here, it is necessary for the extraargs to be provided and it needs to be consistent with the path_integral_routine.","category":"page"},{"location":"tutorial/BasicPI/","page":"Path Integrals","title":"Path Integrals","text":"(Image: TTM QuAPI)","category":"page"},{"location":"documentation/QuAPI/#Quasi-Adiabatic-Propagator-Path-Integral-(QuAPI)","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral (QuAPI)","text":"","category":"section"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"This module provides the basic interface for simulating a system using QuAPI. Though the implementation does not follow the algorithm in the original papers, the first papers to outline the method are QuAPI1 and QuAPI2. For an overall review of the ideas involved, consider reading QuAPI review. ","category":"page"},{"location":"documentation/QuAPI/#API","page":"Quasi-Adiabatic Propagator Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"The API has three important end-points for user interface.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"First, there is the propagate function for propagating a given reduced density matrix.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.propagate","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.propagate","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.propagate","text":"propagate(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, ρ0, dt::Real, ntimes::Int, kmax::Int, extraargs::QuAPIArgs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nGiven a time-series of system forward-backward propagators, fbU, the spectral densities describing the solvent, Jw, and an inverse temperature, this uses QuAPI to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. A non-Markovian memory of kmax steps is used in this simulation. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\nρ0: initial reduced density matrix fbU: time-series of forward-backward propagators Jw: array of spectral densities svec: diagonal elements of system operators through which the corresponding baths interact. QuAPI currently only works for baths with diagonal coupling to the system\n\ndt: time-step for recording the density matrices ntimes: number of time steps of simulation kmax: number of steps within memory extraargs: extra arguments for the QuAPI algorithm. Contains the filtration cutoff threshold\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"Then, there is the build_augmented_propagator function for computing the augmented propagator incorporating the solvent effects through the Feynman-Vernon influence functional. This currently only does a full path calculation and does not iterate.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.build_augmented_propagator","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.build_augmented_propagator","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration. The paths are generated in full forward-backward space but not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of d^2, where d is the dimensionality of the system. This i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.build_augmented_propagator_QuAPI_TTM","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.build_augmented_propagator_QuAPI_TTM","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.build_augmented_propagator_QuAPI_TTM","text":"build_augmented_propagator_QuAPI_TTM(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration. The paths are generated in full forward-backward space but not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of d^2, where d is the dimensionality of the system. This i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:]. In this version, multiple ``types'' of propagators are calculated. These are required to make the TTM scheme consistent with QuAPI splitting.\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"Both of these functions have versions that are parallelised at a shared memory level. Those versions are:","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.build_augmented_propagator_parallel","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.build_augmented_propagator_parallel","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.build_augmented_propagator_parallel","text":"build_augmented_propagator_parallel(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using shared memory parallelism. The paths are generated in full forward-backward space but not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of d^2, where d is the dimensionality of the system. This i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.build_augmented_propagator_QuAPI_TTM_parallel","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.build_augmented_propagator_QuAPI_TTM_parallel","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.build_augmented_propagator_QuAPI_TTM_parallel","text":"build_augmented_propagator_QuAPI_TTM_parallel(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs=QuAPIArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using shared memory parallelism. The paths are generated in full forward-backward space but not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of d^2, where d is the dimensionality of the system. This i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:]. In this version, multiple ``types'' of propagators are calculated. These are required to make the TTM scheme consistent with QuAPI splitting.\n\n\n\n\n\n","category":"function"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI allows for path filtering based on the absolute value of the amplitude of a path. This cutoff threshold is specified using the QuAPIArgs structure. QuAPI.propagate and QuAPI.build_augmented_propagator use objects of this structure, with a default value being the default constructed objected.","category":"page"},{"location":"documentation/QuAPI/","page":"Quasi-Adiabatic Propagator Path Integral","title":"Quasi-Adiabatic Propagator Path Integral","text":"QuAPI.QuAPIArgs","category":"page"},{"location":"documentation/QuAPI/#QuantumDynamics.QuAPI.QuAPIArgs","page":"Quasi-Adiabatic Propagator Path Integral","title":"QuantumDynamics.QuAPI.QuAPIArgs","text":"Filtration parameters for QuAPI. Currently has a threshold for magnitude-based filtering, with a default value of cutoff=0 (no filtering).\n\n\n\n\n\n","category":"type"},{"location":"documentation/Blip/#Blip-decomposition-of-the-path-integral","page":"Blip Decomposition","title":"Blip decomposition of the path integral","text":"","category":"section"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"The blip decomposition of the path integral, as described in Blip1 and Blip2, is a different representation of the path integral that significantly reduces the number of \"paths\" that need to be considered.","category":"page"},{"location":"documentation/Blip/#API","page":"Blip Decomposition","title":"API","text":"","category":"section"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.build_augmented_propagator","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.build_augmented_propagator","page":"Blip Decomposition","title":"QuantumDynamics.Blip.build_augmented_propagator","text":"build_augmented_propagator(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs::BlipArgs=BlipArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using the blip decomposition. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.build_augmented_propagator_parallel","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.build_augmented_propagator_parallel","page":"Blip Decomposition","title":"QuantumDynamics.Blip.build_augmented_propagator_parallel","text":"build_augmented_propagator_parallel(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs::BlipArgs=BlipArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using the blip decomposition in a shared memory parallel manner. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:].\n\n\n\n\n\n","category":"function"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.build_augmented_propagator_QuAPI_TTM","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.build_augmented_propagator_QuAPI_TTM","page":"Blip Decomposition","title":"QuantumDynamics.Blip.build_augmented_propagator_QuAPI_TTM","text":"build_augmented_propagator_QuAPI_TTM(; fbU::Matrix{ComplexF64}, Jw::Vector{T}, β::Real, dt::Real, ntimes::Int, kmax::Union{Int,Nothing}=nothing, extraargs::BlipArgs=BlipArgs(), svec=[1.0 -1.0], reference_prop=false, verbose::Bool=false) where {T<:SpectralDensities.SpectralDensity}\n\nBuilds the propagators, augmented with the influence of the harmonic baths defined by the spectral densities Jw,  upto ntimes time-steps without iteration using the blip decomposition. The paths are, consequently, generated in the space of unique blips and not stored. So, while the space requirement is minimal and constant, the time complexity for each time-step grows by an additional factor of b, where b is the number of unique blip-values. The i^th bath, described by Jw[i], interacts with the system through the diagonal operator with the values of svec[j,:]. In this version, multiple ``types'' of propagators are calculated. These are required to make the TTM scheme consistent with QuAPI splitting.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Blip/","page":"Blip Decomposition","title":"Blip Decomposition","text":"Blip.BlipArgs","category":"page"},{"location":"documentation/Blip/#QuantumDynamics.Blip.BlipArgs","page":"Blip Decomposition","title":"QuantumDynamics.Blip.BlipArgs","text":"Filtration parameters for blips. Currently has the maximum number of blips allowed, which by default is -1 (implying all blips are allowed), and the maximum allowed number of changes in the state of the system along the forward backward path that takes it between two different blip states.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/HEOM/#Hierarchical-Equation-of-Motion","page":"Hierarchical Equations of Motion","title":"Hierarchical Equation of Motion","text":"","category":"section"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"The HEOM family of methods is an extremely popular set of methods for solving the system-harmonic bath problem. While exact like QuAPI, its initial formulation was efficient for the Ohmic spectral density with a Drude-Lorentz cutoff. While a lot of significant work has gone into improving the performance of the method, and increasing the generality, the implementation in QuAPI is currently quite basic and can only handle Drude spectral densities.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"TO propagate an initial reduced density matrix using HEOM, we define a Hamiltonian and specify the spectral density and the temperature. Unlike QuAPI, HEOM can incorporate baths interacting with the system through non-diagonal operators without any increase in the complexity of the algorithm. However, for comparison purposes, in this tutorial, we restrict our attention to diagonal system-bath couplings.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"using QuantumDynamics\nusing Plots, LaTeXStrings\n\nH0 = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)        # 1.1 Define the system Hamiltonian\nρ0 = [1.0+0.0im 0; 0 0]\nβ = 0.5\nJw = SpectralDensities.DrudeLorentz(; λ=1.5, γ=7.5)\ndt = 0.125\nntimes = 200","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"We call the propagate function","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"times_HEOM, ρs_HEOM = HEOM.propagate(; Hamiltonian=H0, ρ0, β, dt, ntimes, Jw=[Jw], sys_ops=[[1.0+0.0im 0.0; 0.0 -1.0]], num_modes=1, Lmax=2)","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"For comparison, we also simulate the system using QuAPI and plot the results.","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"barefbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt, ntimes);\ntimes, ρs = TEMPO.propagate(; fbU=barefbU, Jw=[Jw], β, ρ0, dt, ntimes, kmax=10)","category":"page"},{"location":"tutorial/HEOM/","page":"Hierarchical Equations of Motion","title":"Hierarchical Equations of Motion","text":"(Image: HEOM)","category":"page"},{"location":"documentation/Bare/#Bare-System-Propagation","page":"Bare System Propagation","title":"Bare System Propagation","text":"","category":"section"},{"location":"documentation/Bare/#API","page":"Bare System Propagation","title":"API","text":"","category":"section"},{"location":"documentation/Bare/","page":"Bare System Propagation","title":"Bare System Propagation","text":"Bare.propagate","category":"page"},{"location":"documentation/Bare/#QuantumDynamics.Bare.propagate","page":"Bare System Propagation","title":"QuantumDynamics.Bare.propagate","text":"propagate(; Hamiltonian::AbstractMatrix{ComplexF64}, ρ0::AbstractMatrix{ComplexF64}, dt::Real, ntimes::Int, L::Union{Nothing,Vector{Matrix{ComplexF64}}}=nothing, external_fields::Union{Nothing,Vector{Utilities.ExternalField}}=nothing, extraargs::Utilities.DiffEqArgs=Utilities.DiffEqArgs())\n\nGiven a potentially non-Hermitian Hamiltonian, this solves the equation of motion to propagate the input initial reduced density matrix, ρ0, with a time-step of dt for ntimes time steps. If a solution to the Lindblad Master Equation is desired, make the Hamiltonian Hermitian, and keep all the non-Hermitian dissipative operators in L.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Collection of some utilities for simulations.","category":"page"},{"location":"documentation/Utilities/#API","page":"Utilities","title":"API","text":"","category":"section"},{"location":"documentation/Utilities/#ITensor-Utilities","page":"Utilities","title":"ITensor Utilities","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.convert_ITensor_to_matrix","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.convert_ITensor_to_matrix","page":"Utilities","title":"QuantumDynamics.Utilities.convert_ITensor_to_matrix","text":"convert_ITensor_to_matrix(tens, sinit, sterm)\n\nConverts an ITensor with two indices to a matrix. The index sinit is mapped to the column and sterm is mapped to the row.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.identity_MPO","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.identity_MPO","page":"Utilities","title":"QuantumDynamics.Utilities.identity_MPO","text":"identity_MPO(sites)\n\nReturns the identity MPO based on the given sites.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.MPO_to_MPS","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.MPO_to_MPS","page":"Utilities","title":"QuantumDynamics.Utilities.MPO_to_MPS","text":"MPO_to_MPS(ρ::MPO, fbcombiner)\n\nConvert a given MPO to an MPS by combining the two site indices on every tensor into a single one using the vector of combiner tensors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.MPS_to_MPO","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.MPS_to_MPO","page":"Utilities","title":"QuantumDynamics.Utilities.MPS_to_MPO","text":"MPO_to_MPS(ρ::MPO, fbcombiner)\n\nSplit a given MPS to an MPO by using the vector of combiner tensors.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"ITensors.expect","category":"page"},{"location":"documentation/Utilities/#ITensors.expect","page":"Utilities","title":"ITensors.expect","text":"ITensors.expect(ρ::MPO, ops; kwargs...)\n\nExtends ITensors' expect function to handle density matrices in the form of MPOs.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/#HDF5-Utilities","page":"Utilities","title":"HDF5 Utilities","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.create_and_select_group","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.create_and_select_group","page":"Utilities","title":"QuantumDynamics.Utilities.create_and_select_group","text":"create_and_select_group(base, new_group)\n\nChecks if new_group exists in base. Selects it if it does, else creates it.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.check_or_insert_value","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.check_or_insert_value","page":"Utilities","title":"QuantumDynamics.Utilities.check_or_insert_value","text":"check_or_insert_value(base, variable, value)\n\nInserts value into base[variable].  If it already exists, checks if the value is correct, and throws if not.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.merge_into","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.merge_into","page":"Utilities","title":"QuantumDynamics.Utilities.merge_into","text":"merge_into(source::String, destination::String)\n\nMerge data from the HDF5 file at source to the one at destination.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/#Generic-Utilities","page":"Utilities","title":"Generic Utilities","text":"","category":"section"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.get_BLAS_implementation","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.get_BLAS_implementation","page":"Utilities","title":"QuantumDynamics.Utilities.get_BLAS_implementation","text":"get_BLAS_implementation()\n\nReports the BLAS implementation under use. The default implementation used by Julia is OpenBlas. MKL is supported through the external package MKL.jl, which needs to be installed and loaded before the loading of QuantumDynamics.jl\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.trapezoid","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.trapezoid","page":"Utilities","title":"QuantumDynamics.Utilities.trapezoid","text":"trapezoid(x, y; discrete::Bool=false)\n\nReturns the trapezoidal integration of y with respect to x. If discrete is set to true, then returns sum of y.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.commutator","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.commutator","page":"Utilities","title":"QuantumDynamics.Utilities.commutator","text":"commutator(A, B)\n\nReturns the commutator A and B: AB - BA.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.calculate_Liouvillian","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.calculate_Liouvillian","page":"Utilities","title":"QuantumDynamics.Utilities.calculate_Liouvillian","text":"calculate_Liouvillian(Hamiltonian::AbstractMatrix{Complex})\n\nReturns the Liouvillian corresponding to the given Hamiltonian.\n\n\n\n\n\ncalculate_Liouvillian(H::OpSum, sites)\n\nReturns the forward-backward space combiner and the Liouvillian MPO corresponding to the Hamiltonian provided as an ITensor OpSum, to be built on the sites.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.ExternalField","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.ExternalField","page":"Utilities","title":"QuantumDynamics.Utilities.ExternalField","text":"ExternalField provides an abstract interface for encoding an external field, V(t), interacting with the system through the operator, coupling_op.\n\n\n\n\n\n","category":"type"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.density_matrix_to_vector","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.density_matrix_to_vector","page":"Utilities","title":"QuantumDynamics.Utilities.density_matrix_to_vector","text":"density_matrix_to_vector(ρ::AbstractMatrix{<:Complex})\n\nReturns the vector representation of the density matrix ρ compatible with the forward-backward propagators.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.density_matrix_vector_to_matrix","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.density_matrix_vector_to_matrix","page":"Utilities","title":"QuantumDynamics.Utilities.density_matrix_vector_to_matrix","text":"density_matrix_vector_to_matrix(ρvec::AbstractVector{<:Complex})\n\nReturns the matrix form of the vector ρvec.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.hash_path","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.hash_path","page":"Utilities","title":"QuantumDynamics.Utilities.hash_path","text":"hash_path(states, sdim)\n\nReturns the hashed location of a path for a system with sdim dimensions.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.unhash_path","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.unhash_path","page":"Utilities","title":"QuantumDynamics.Utilities.unhash_path","text":"unhash_path(path_num::Int, ntimes::Int, sdim::Int)\n\nConstruct a path for a system with sdim dimensions, corresponding to the number path_num, with ntimes time steps.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.unhash_path_blips","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.unhash_path_blips","page":"Utilities","title":"QuantumDynamics.Utilities.unhash_path_blips","text":"unhash_path_blips(ntimes::Int, sdim::Int, nblips::Int)\n\nConstruct all the paths for a system with sdim dimensions with ntimes time steps and nblips blips.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.apply_propagator","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.apply_propagator","page":"Utilities","title":"QuantumDynamics.Utilities.apply_propagator","text":"apply_propagator(; propagators, ρ0, ntimes, dt)\n\nApply a series of ntimes propagators to an initial reduced density matrix ρ0 and return the result as a tuple of (time, ρs).\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"There are a few utilities for creating specific kinds of Hamiltonians.","category":"page"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.create_tls_hamiltonian","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.create_tls_hamiltonian","page":"Utilities","title":"QuantumDynamics.Utilities.create_tls_hamiltonian","text":"create_tls_hamiltonian(; ϵ::AbstractFloat, Δ::AbstractFloat)\n\nCreates a two-level system Hamiltonian:\n\nH = fracϵ2σ_z - fracΔ2σ_x\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.create_nn_hamiltonian","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.create_nn_hamiltonian","page":"Utilities","title":"QuantumDynamics.Utilities.create_nn_hamiltonian","text":"create_nn_hamiltonian(; site_energies::AbstractVector{AbstractFloat}, couplings::AbstractVector{AbstractFloat}, periodic::Bool)\n\nCreates a nearest neighbour Hamiltonian with the given site_energies and couplings. Periodic boundary conditions can also be used by passing true into the periodic argument.\n\n\n\n\n\n","category":"function"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Many of the algorithms require extra, method-specific arguments. These are implemented as subtypes of Utilities.ExtraArgs.","category":"page"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.ExtraArgs","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.ExtraArgs","page":"Utilities","title":"QuantumDynamics.Utilities.ExtraArgs","text":"Abstract type for encoding all the method specific numerical parameters.\n\n\n\n\n\n","category":"type"},{"location":"documentation/Utilities/","page":"Utilities","title":"Utilities","text":"Utilities.DiffEqArgs","category":"page"},{"location":"documentation/Utilities/#QuantumDynamics.Utilities.DiffEqArgs","page":"Utilities","title":"QuantumDynamics.Utilities.DiffEqArgs","text":"Extra parameters for solving differential equations. Currently has a threshold for magnitude-based filtering. The default values are:     reltol = 1e-10     abstol = 1e-10     solver = Tsit5()\n\n\n\n\n\n","category":"type"},{"location":"documentation/QCPI/#Quantum-Classical-Path-Integral","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"","category":"section"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI provides a rigorous way of coupling a classical-like solvent to a quantum system. The method has been outlined in QCPI1, QCPI2, reference propagators.","category":"page"},{"location":"documentation/QCPI/#API","page":"Quantum-Classical Path Integral","title":"API","text":"","category":"section"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"QCPI.propagate","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.QCPI.propagate","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.QCPI.propagate","text":"propagate(; Hamiltonian::Matrix{ComplexF64}, Jw::SpectralDensities.SpectralDensity, solvent::Solvents.Solvent, ρ0::Matrix{ComplexF64}, classical_dt::Real, dt::Real, ntimes::Int, kmax::Int, path_integral_routine, extraargs::Utilities.ExtraArgs, svec=[1.0 -1.0], verbose::Bool=false)\n\nUse QCPI to propagate an initial density matrix, ρ0, under a given Hamiltonian with a solvent that is described by solvent and a corresponding spectral density Jw.\n\n\n\n\n\n","category":"function"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The solvent shown here is encoded in the Solvents submodule:","category":"page"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents","text":"General description of different types of solvents.\n\n\n\n\n\n","category":"module"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"The Solvents submodule defines a general Solvent type and an associated PhaseSpace type.","category":"page"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents.Solvent","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents.Solvent","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents.Solvent","text":"Abstract type for every solvent. Every solvent needs to implement Base.iterate, which returns the next sample of the phase-space, and a propagate_trajectory method which propagates a given phasespace point using classical mechanics.\n\n\n\n\n\n","category":"type"},{"location":"documentation/QCPI/","page":"Quantum-Classical Path Integral","title":"Quantum-Classical Path Integral","text":"Solvents.PhaseSpace","category":"page"},{"location":"documentation/QCPI/#QuantumDynamics.Solvents.PhaseSpace","page":"Quantum-Classical Path Integral","title":"QuantumDynamics.Solvents.PhaseSpace","text":"Abstract type for all phase spaces. Each Solvent has an associated phase-space.\n\n\n\n\n\n","category":"type"},{"location":"documentation/Forster/#Incoherent-Forster-Theory","page":"Incoherent Forster Theory","title":"Incoherent Forster Theory","text":"","category":"section"},{"location":"documentation/Forster/#API","page":"Incoherent Forster Theory","title":"API","text":"","category":"section"},{"location":"documentation/Forster/","page":"Incoherent Forster Theory","title":"Incoherent Forster Theory","text":"Forster.build_incoherent_propagator","category":"page"},{"location":"documentation/Forster/#QuantumDynamics.Forster.build_incoherent_propagator","page":"Incoherent Forster Theory","title":"QuantumDynamics.Forster.build_incoherent_propagator","text":"build_incoherent_propagator(Jws::Vector{SpectralDensities.SpectralDensityTable}, H::Matrix{ComplexF64}, dt::Float64, β::Float64; verbose::Bool=false)\n\nCalculate the incoherent propagator and rate matrix under the approximation Forster theory.\n\n\n\n\n\n","category":"function"},{"location":"documentation/EtaCoefficients/#η-Coefficients","page":"Eta Coefficients","title":"η-Coefficients","text":"","category":"section"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"The η-coefficients are discretizations of the bath correlation function required for simulations using the QuAPI influence functionals. QuantumDynamics provides facilities for generating these coefficients and storing them in a way that utilizes the limited time-translational symmetry that they demonstrate. These coefficients have been listed in many papers, the first being QuAPI1.","category":"page"},{"location":"documentation/EtaCoefficients/#API","page":"Eta Coefficients","title":"API","text":"","category":"section"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"EtaCoefficients.EtaCoeffs","category":"page"},{"location":"documentation/EtaCoefficients/#QuantumDynamics.EtaCoefficients.EtaCoeffs","page":"Eta Coefficients","title":"QuantumDynamics.EtaCoefficients.EtaCoeffs","text":"EtaCoefficients holds the various discretized η-coefficients required for a QuAPI-based simulation. These are the minimum number of coefficients required, stored using time-translational symmetry wherever possible.\n\nThe values are stored as follows: η00: The self-interaction of the two terminal time points. ηmm: The self-interaction of all intermediate points. η0m: The interaction between a terminal and an intermediate point at different time separations. ηmn: The interaction between two intermediate points at different time separations. η0e: The interaction between the two terminal points at different time separations.\n\n\n\n\n\n","category":"type"},{"location":"documentation/EtaCoefficients/","page":"Eta Coefficients","title":"Eta Coefficients","text":"EtaCoefficients.calculate_η","category":"page"},{"location":"documentation/EtaCoefficients/#QuantumDynamics.EtaCoefficients.calculate_η","page":"Eta Coefficients","title":"QuantumDynamics.EtaCoefficients.calculate_η","text":"calculate_η(specdens::T; β::Real, dt::Real, kmax::Int, classical::Bool=false, imaginary_only=false) where {T<:SpectralDensities.ContinuousSpectralDensity}\n\nCalculates the η-coefficients from an analytic spectral density and returns them as an object of the structure EtaCoeffs. The integrations involved are done using trapezoidal integration\n\n\n\n\n\ncalculate_η(specdens::SpectralDensity.DiscreteOscillators; β::Real, dt::Real, kmax::Int, classical::Bool=false, imaginary_only=false)\n\nCalculates the η-coefficients from a discretized set of harmonic modes and returns them as an object of the structure EtaCoeffs. The integrations involved are converted to sums over frequency modes.\n\n\n\n\n\n","category":"function"},{"location":"#Quantum-Dynamics","page":"Introduction","title":"Quantum Dynamics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation Tests\n(Image: Dev) (Image: Run tests)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumDynamics is an open-source software for the simulation of open quantum systems. Though written with performance in mind, QuantumDynamics provides a high throughput platform for experimentation with state-of-the-art approaches to method development.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The primary problem that QuantumDynamics is aimed at solving is the simulation of the dynamics of a relatively small quantum system coupled to a dissipative environment. Such a system-solvent decomposed problem can typically be represented by the Hamiltonian:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hatH = hatH_0 + hatH_textenv","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where hatH_0 is the Hamiltonian of the isolated system and hatH_textenv is the Hamiltonian corresponding to the environment and the interaction between the system and the environment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As demonstrated in the tutorials and the example codes, QuantumDynamics provides some approximate methods for simulating the dynamics of the system. However, the goal of this package is to provide access to more state-of-the-art techniques based on path integrals, tensor networks and other ideas in such a manner that all of these methods can be used as far as possible in a composable manner.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The QuantumDynamics.jl package is registered. The installation can either be done by going into the Pkg REPL mode for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> add QuantumDynamics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or by using the Pkg package manager in a script:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"QuantumDynamics\")","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use QuantumDynamics in your work, please cite the QuantumDynamics.jl paper:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{10.1063/5.0151483,\n    author = {Bose, Amartya},\n    title = \"{QuantumDynamics.jl: A modular approach to simulations of dynamics of open quantum systems}\",\n    journal = {The Journal of Chemical Physics},\n    volume = {158},\n    number = {20},\n    year = {2023},\n    month = {05},\n    abstract = \"{A simulation of the non-adiabatic dynamics of a quantum system coupled to dissipative environments poses significant challenges. New sophisticated methods are regularly being developed with an eye toward moving to larger systems and more complicated descriptions of solvents. Many of these methods, however, are quite difficult to implement and debug. Furthermore, trying to make the individual algorithms work together through a modular application programming interface can be quite difficult as well. We present a new, open-source software framework, QuantumDynamics.jl, designed to address these challenges. It provides implementations of a variety of perturbative and non-perturbative methods for simulating the dynamics of these systems. Most prominently, QuantumDynamics.jl supports hierarchical equations of motion and methods based on path integrals. An effort has been made to ensure maximum compatibility of the interface between the various methods. Additionally, QuantumDynamics.jl, being built on a high-level programming language, brings a host of modern features to explorations of systems, such as the usage of Jupyter notebooks and high level plotting, the possibility of leveraging high-performance machine learning libraries for further development. Thus, while the built-in methods can be used as end-points in themselves, the package provides an integrated platform for experimentation, exploration, and method development.}\",\n    issn = {0021-9606},\n    doi = {10.1063/5.0151483},\n    url = {https://doi.org/10.1063/5.0151483},\n    note = {204113},\n    eprint = {https://pubs.aip.org/aip/jcp/article-pdf/doi/10.1063/5.0151483/17794821/204113\\_1\\_5.0151483.pdf},\n}","category":"page"},{"location":"tutorial/Bloch-Redfield/#Bloch-Redfield-Master-Equation","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"","category":"section"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"QuantumDynamics also offers the option of simulating the dynamics of an open quantum system using the Bloch-Redfield equations. The main interface is similar to that of the path integral-based methods except for the crucial difference that instead of building on the forward-backward propagator, the Bloch-Redfield Master Equations (BRME) uses the Hamiltonian.","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"First, we define the system and the spectral density describing the solvent","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"using QuantumDynamics\n\nH0 = Utilities.create_tls_hamiltonian(; ϵ=0.0, Δ=2.0)        # 1.1 Define the system Hamiltonian\nJw = SpectralDensities.ExponentialCutoff(; ξ=0.1, ωc=7.5)    # 1.2 Define the spectral density\nβ = 5.0    # 1.3 Inverse temperature\ndt = 0.25\nntimes = 100\nρ0 = [1.0+0.0im 0; 0 0]","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"The interface to BRME is provided in the Bloch-Redfield module as the propagate function.","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"time, ρs = BlochRedfield.propagate(; Hamiltonian=H0, Jw=[Jw], β, ρ0, dt, ntimes, sys_ops=[[1.0+0.0im 0.0; 0.0 -1.0]])","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"Let's also do a QuAPI calculation for comparison:","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"fbU = Propagators.calculate_bare_propagators(; Hamiltonian=H0, dt=dt, ntimes=ntimes)\nt, ρs_quapi = QuAPI.propagate(; fbU=fbU, Jw=[Jw], β=β, ρ0=ρ0, dt=dt, ntimes=ntimes, kmax=7)","category":"page"},{"location":"tutorial/Bloch-Redfield/","page":"Bloch-Redfield Master Equation","title":"Bloch-Redfield Master Equation","text":"(Image: Comparison between Redfield and QuAPI)","category":"page"}]
}
